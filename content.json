{"meta":{"title":"Kate Park's Blog","subtitle":"","description":"","author":"Kate Park","url":"http://katepark1009.github.io","root":"/"},"pages":[],"posts":[{"title":"UI Library를 만들어보자!","slug":"UI-Library","date":"2019-11-26T22:57:55.000Z","updated":"2019-12-02T19:12:43.777Z","comments":true,"path":"2019/11/26/UI-Library/","link":"","permalink":"http://katepark1009.github.io/2019/11/26/UI-Library/","excerpt":"","text":"UI Library를 만들자 (1) - rollup.js회사에서 이번 분기의 큰 프로젝트 일환으로 UI 라이브러리를 만들게 되었다!웹팩을 공부하고, 해당 내용을 적용시킬 수 있는 좋은 계기가 될 것 같다!고 생각했는데이번 프로젝트에서는 rollup.js을 사용하게 되었다.웹팩이랑 비슷한 역할을 하는 모듈번들러인것 같아서 다시 rollup공부를 해야하기에.다시금 공부모드로..+_+ rollup이란?공식 사이트에 따르면, Rollup is a module bundler for JavaScript which compiles small pieces of code into something larger and more complex, such as a library or application. It uses the new standardized format for code modules included in the ES6 revision of JavaScript, instead of previous idiosyncratic solutions such as CommonJS and AMD. ES modules let you freely and seamlessly combine the most useful individual functions from your favorite libraries. This will eventually be possible natively everywhere, but Rollup lets you do it today. 설명만 보자면 웹팩과 거의 역할이 동일해보인다….. 그렇다면 웹팩 대비 장점은? Rollup includes the bare minimum, it results in lighter, faster, and less complicated libraries and applications. 더 가볍고 빠르고 덜 복잡하다 한다. rollup 설정하기 - rollup.config.jsrollup도 webpack과 마찬가지고 configuration 파일을 만들어줘야 함.input, output의 모양새가 webpack.config와 매우매우매우 비슷하다. 12345678910111213141516//rollup.config.js module.exports = &#123; input: 'src/main.js', output: &#123; file: 'bundle.js', format: 'cjs', name: 'bundle', globals: &#123; jquery: '$' &#125;, plugins: [ resolve(), commonjs() ] &#125;&#125;; input - The bundle’s entry point(s) (e.g. your main.js or app.js or index.js). If you provide an array of entry points or an object mapping names to entry points, they will be bundled to separate output chunks. output - It’s an object like configuration where we set up the result of our processing. Minimum of the configuration is to include the: 2.1 file - This is the location where our bundle will be created. It represents the file to write to. Usually under the build or dist folder. The folder and the file will be generated automatically by rollup 2.2 format - Rollup supports several output formats. amd – Asynchronous Module Definition, used with module loaders like RequireJS cjs – CommonJS, suitable for Node and other bundlers esm – Keep the bundle as an ES module file, suitable for other bundlers and inclusion as a tag in modern browsers iife – A self-executing function, suitable for inclusion as a tag. (If you want to create a bundle for your application, you probably want to use this.) umd – Universal Module Definition, works as amd, cjs and iife all in one system – Native format of the SystemJS loader 2.3 name - Necessary for iife/umd bundles, Global variable name representing the created bundle 2.4 globals - Specifies id: variableName pairs necessary for external imports in umd/iife bundles. 123456import $ from &apos;jquery&apos;//rollup.config.js globals: &#123; jquery: &apos;$&apos; &#125; plugins - plugins change the behaviour of Rollup at key points in the bundling process. (Plugin list : https://github.com/rollup/awesome)importing modules installed with NPM, compiling code with Babel, working with JSON files and so on. rollup config에 넣을 수 있는 big list of options!본인들이 BIG LIST라고 언급한것처럼 옵션이 정말 많다.; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// rollup.config.jsexport default &#123; // can be an array (for multiple inputs) // core input options external, input, // required plugins, // advanced input options cache, inlineDynamicImports, manualChunks, onwarn, preserveModules, strictDeprecations, // danger zone acorn, acornInjectPlugins, context, moduleContext, preserveSymlinks, shimMissingExports, treeshake, // experimental chunkGroupingSize, experimentalCacheExpiry, experimentalOptimizeChunks, experimentalTopLevelAwait, perf, output: &#123; // required (can be an array, for multiple outputs) // core output options dir, file, format, // required globals, name, plugins, // advanced output options assetFileNames, banner, chunkFileNames, compact, entryFileNames, extend, footer, interop, intro, outro, paths, sourcemap, sourcemapExcludeSources, sourcemapFile, sourcemapPathTransform, // danger zone amd, dynamicImportFunction, esModule, exports, externalLiveBindings, freeze, indent, namespaceToStringTag, noConflict, preferConst, strict &#125;, watch: &#123; chokidar, clearScreen, exclude, include &#125;&#125;;// rollup.config.js (building more than one bundle)export default [&#123; input: 'main-a.js', output: &#123; file: 'dist/bundle-a.js', format: 'cjs' &#125;&#125;, &#123; input: 'main-b.js', output: [ &#123; file: 'dist/bundle-b1.js', format: 'cjs' &#125;, &#123; file: 'dist/bundle-b2.js', format: 'esm' &#125; ]&#125;]; NPM package.json에서 config사용하기scripts에 rollup 적용하기, -c : config 파일 경로, 경로 안적는 경우는 defaults to rollup.config.js -o : 번들 후 결과 파일, Single output file (if absent, prints to stdout) --environment : process.ENV를 통해 환경변수 전달 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;rollup -c -o dist/index.min.js&quot;&#125; Plugin 사용하기공식 사이트 플러그인 주소: https://github.com/rollup/awesome 내가 사용중인 플러그인12345plugins: [ babel(&#123; exclude: 'node_modules/**' &#125;), uglify(), svg()]","categories":[],"tags":[{"name":"rollup.js","slug":"rollup-js","permalink":"http://katepark1009.github.io/tags/rollup-js/"}]},{"title":"Webpack 공부해보자!","slug":"webpack","date":"2019-11-26T00:19:56.000Z","updated":"2019-11-26T01:29:20.842Z","comments":true,"path":"2019/11/25/webpack/","link":"","permalink":"http://katepark1009.github.io/2019/11/25/webpack/","excerpt":"","text":"Webpack?한마디로 Module bundler.웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고이를 조합해서 병합된 *하나의 결과물을 만드는 도구를 의미. 서로 연관 관계가 있는 웹 자원들을 js, css, img와 같은 static한 자원으로 변환시켜주는 모듈 번들러이며모든 웹 자원(html, css ,js)을 모듈형태로 로딩 가능.초기에 모두 로딩하지 않고, 필요할 때 필요한 것만 그때 그때 요청해서 로딩하여 사용함. 웹팩 등장 이유 파일 단위의 자바스크립트 모듈 관리가 필요함 (전역 범위의 변수가 겹치는 현상 방지)➡ ES6의 Modules문법, 모듈 번들링으로 해결함. 웹 개발 작업 자동화 하는 도구 (Dev 모드에서 변화를 실시간 확인 가능) 앱의 빠른 로딩 속도와 높은 성능 (필요한 것만 그때그때 로딩) 웹팩을 이용해 여러 개의 파일을 하나로 합치면 위와 같은 브라우저별 HTTP 요청 숫자 제약을 피할 수 있음. 웹팩의 4가지 주요 속성 entry output loader plugin Entry entry는 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로. 1234// webpack.config.jsmodule.exports = &#123; entry: './src/index.js'&#125; 이 과정에서 index.js안에 있는 Home.js, LogIn.js등 여러 파일이 함께 빌드 됨. 이처럼 모듈 간의 의존 관계가 생기는 구조를 디펜던시 그래프(Dependency Graph)라고 함. Output output은 웹팩을 돌리고 난 결과물의 파일 경로. output은 옵션을 지정해줘야함! 최소한 filename은 지정해줘야 하며 일반적으로 아래와 같이 path 속성을 함께 정의함. 12345678// webpack.config.jsmodule.exports = &#123; output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist') &#125; //output: './dist/bundle.js'와 같음.&#125; filename속성에 추가 할 수 있는 옵션 &#39;[name].bundle.js&#39; : 파일 이름에 entry 속성을 포함 &#39;[id].bundle.js&#39; : 웹팩 내부적으로 사용하는 모듈 ID를 포함 &#39;[name].[hash].bundle.js&#39; : 매 빌드시 마다 고유 해시 값 &#39;[chunkhash].bundle.js&#39; : 웹팩의 각 모듈 내용을 기준으로 생생된 해시 값 Loader 로더(Loader)는 웹팩이 웹 애플리케이션을 해석할 때 자바스크립트 파일이 아닌 웹 자원(HTML, CSS, Images, 폰트 등)들을 변환할 수 있도록 도와주는 속성 기본적으로 오른쪽에서 왼쪽 순으로 적용 123456// webpack.config.jsmodule.exports = &#123; module: &#123; rules: [] &#125;&#125; CSS Loader12345678910module: &#123; rules: [ &#123; test: /\\.css$/, //test : 로더를 적용할 파일 유형 (일반적으로 정규 표현식 사용) use: ['css-loader'] //use : 해당 파일에 적용할 로더의 이름 &#125; ] &#125; 먼저 Sass 로더로 전처리(scss 파일을 css 파일로 변환)를 한 다음 웹팩에서 CSS 파일을 인식할 수 있게 CSS 로더를 적용 123456789//SCSS 파일에 로더를 적용하는 예시module: &#123; rules: [ &#123; test: /\\.scss$/, use: ['css-loader', 'sass-loader'] //오른쪽 먼저 실행됨 sass -&gt; css &#125; ]&#125; 여러가지 로더 종류 Babel Loader Sass Loader File Loader Vue Loader TS Loader 내가 쓰는 loader12345678910111213141516171819202122232425262728293031323334353637383940config.module = &#123; rules: [ &#123; test: /\\.(js|jsx)$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.s?css$/, use: [ MiniCssExtractPlugin.loader, //MiniCssExtractPlugin = CSS 파일을 별도로 분리하기 위해 사용 &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125;, &#123; test: /\\.(png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/, loader: 'file-loader' &#125;, &#123; test: /\\.html$/, use: [ &#123; loader: 'html-loader', options: &#123; minimize: true &#125; &#125; ] &#125; ] &#125; Plugin플러그인(plugin)은 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성입니다.로더랑 비교하면 로더는 파일을 해석하고 변환하는 과정에 관여하는 반면,플러그인은 해당 결과물의 형태를 바꾸는 역할을 한다고 보면 됩니다. 생성자 함수로 생성한 객체 인스턴스만 추가가능. new 키워드워 함께. 12345678910// webpack.config.jsvar webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; plugins: [ new HtmlWebpackPlugin(), new webpack.ProgressPlugin() ]&#125; 내가 사용중인 Plugin1config.plugins = [CSSPlugin, DefinePlug, CleanPLugin, AnalyzerPlugin, HTMLPlugin, CopyPlugin] Webpack Dev server1234567891011121314151617181920212223242526272829// npm i webpack webpack-cli webpack-dev-server html-webpack-plugin -D 명령어 실행 후,&#123; // package.json \"scripts\": &#123; \"dev\": \"webpack-dev-server\" &#125;,&#125;//webpack.config.jsvar path = require('path');var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'none', entry: './index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, devServer: &#123; port: 9000, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // index.html 템플릿을 기반으로 빌드 결과물을 추가해줌 template: 'index.html', &#125;), ],&#125;; Webpack 4 - mode모드는 총 3가지. none : 모드 설정 안함 development : 개발 모드 production : 배포 모드(기본값) 12345module.exports = &#123; mode: 'none', entry: '', // ...&#125; 참고🧡웹팩 핸드북: https://joshua1988.github.io/webpack-guide/webpack 공식 사이트: https://webpack.js.org/configuration/","categories":[],"tags":[{"name":"webpack, 웹팩, react, 리액트","slug":"webpack-웹팩-react-리액트","permalink":"http://katepark1009.github.io/tags/webpack-%EC%9B%B9%ED%8C%A9-react-%EB%A6%AC%EC%95%A1%ED%8A%B8/"}]},{"title":"첫 포스트! Hexo 블로그 설치","slug":"My-first-Post","date":"2019-11-23T00:55:41.000Z","updated":"2019-11-25T22:51:58.744Z","comments":true,"path":"2019/11/22/My-first-Post/","link":"","permalink":"http://katepark1009.github.io/2019/11/22/My-first-Post/","excerpt":"","text":"처음으로 hexo를 설치해 보았다.참으로 여기저기를 돌아서 마침내 테마 적용도 완료!매우 뿌듯함니닷. 1console.log(&apos;hello, hexo&apos;);","categories":[],"tags":[{"name":"hexo, hexo-blog","slug":"hexo-hexo-blog","permalink":"http://katepark1009.github.io/tags/hexo-hexo-blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-23T00:51:38.078Z","updated":"2019-11-23T00:51:38.078Z","comments":true,"path":"2019/11/22/hello-world/","link":"","permalink":"http://katepark1009.github.io/2019/11/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}